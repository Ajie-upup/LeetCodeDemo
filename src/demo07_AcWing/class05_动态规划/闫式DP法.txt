DP
    - 状态表示（f(v,j)）
        - 集合：所有只考虑前 i 个物品，且总体积不超过 j 的集合
        - 属性：求 max （背包能容纳的最大体积的物品，背包容纳物品的最大价值）
    - 状态计算
        - 所有不选第 v 个物品的集合 f(v-1,j)
        - 所有选第 v 个物品的集合  f(v-1,j-v[i]) + w[j]

1. 01背包(每件物品只能使用一次)：
    二维：
        f[i][j] = max(f[i - 1][j],f[i - 1][j - v] + w)
        1. 状态 f[i][j] 定义：前 i 个物品，背包容量 j 下的最优解（最大价值）
        2. 当前背包容量不够（j < v[i]），没得选，因此前 i 个物品最优解即为前 i−1 个物品最优解
            f[i][j] = f[i - 1][j]
        3. 当前背包容量够，可以选，因此需要决策选与不选第 i 个物品（两者取最大值）
            选：f[i][j] = f[i - 1][j - v[i]] + w[i]
            不选：f[i][j] = f[i - 1][j]

    一维：
        1. 状态 f[j] 定义：N 件物品，背包容量 j 下的最优解（枚举背包容量 j 必须从 m 开始）
        2. 状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i]

    为什么一维情况下枚举背包容量需要逆序？
        在二维情况下，状态f[i][j]是由上一轮 i - 1 的状态得来的，f[i][j] 与 f[i - 1][j] 是独立的。
        而优化到一维后，如果我们还是正序，则有 f[较小体积] 更新到 f[较大体积]，则有可能本应该用第 i - 1 轮的状态却用的是第 i 轮的状态

2. 完全背包(每件物品可以使用无数次)：
    二维：
        f[i][j] = max(f[i - 1][j],f[i][j - v] + w)
    一维：
        f[j] = max(f[j], f[j - v[i]] + w[i]  (逆序)

3. 多重背包(每件物品使用的次数通过输入获取)：








